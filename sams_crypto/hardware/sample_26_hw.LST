C51 COMPILER V7.10   SAMPLE_26_HW                                                          08/04/2011 10:36:56 PAGE 1   


C51 COMPILER V7.10, COMPILATION OF MODULE SAMPLE_26_HW
OBJECT MODULE PLACED IN sample_26_hw.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE sample_26_hw.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*
   2            Copyright (c) 2011, Ciho Software Technology CO.,Ltd
   3            All rights reserved.
   4            
   5            File£ºsample_26_hw.c
   6              
   7          */
   8          
   9          #include <string.h>
  10          #include "ses_v3.h"
  11          #include "..\inc\sample_26.h"
  12          
  13          #define _DEBUG
  14          
  15          /* global variable defination. */
  16          unsigned char last_ses_error = 0; /* last SES error */
  17          IO_PACKAGE out_pkg;  /* output package */
  18          IO_PACKAGE *output = &out_pkg; 
  19          IO_PACKAGE *input = (IO_PACKAGE *)pbInBuff; /* input package */
  20          unsigned char tmp_buf[MAX_IO_DATA_SIZE];
  21          
  22          /*
  23                  Exit upon an error.
  24            
  25                  Parameters:
  26                          errcode[in]: error code
  27                          msg[in]: additional error message
  28                          msglen[in]: message length
  29            
  30                  Return:
  31                          none.
  32          
  33                  Remarks:
  34                          none.
  35          */
  36          void error_exit(unsigned char errcode, unsigned char *msg, int msglen)
  37          {
  38   1              output->tag = errcode;
  39   1              output->len = 0;
  40   1              
  41   1              /* for debug purpose only */
  42   1      #ifdef  _DEBUG
  43   1              if (msglen != 0 && msg != NULL)
  44   1              {
  45   2                      memcpy(output->buff, msg, msglen);
  46   2                      output->len = msglen;
  47   2              }
  48   1      #endif
  49   1      
  50   1              _set_response(2+output->len, (unsigned char *)output);
  51   1              _exit();
  52   1      }
  53          /*
  54                  This function do DES/TDES en/decryption in ECB mode .
  55                  
C51 COMPILER V7.10   SAMPLE_26_HW                                                          08/04/2011 10:36:56 PAGE 2   

  56                  Parameters:
  57                          cmd[in]: command 
  58                          key[in]: secret key
  59                          in[in]:  input data
  60                          inlen[in]: input data length
  61                          out[out]: output data
  62                          outlen[in,out]: [in]out buffer size &&[out]output length 
  63                  Return: 
  64                          If the function succeeds, it will return ERR_SUCCESS, otherwise 
  65                          it returns corresponding error code.
  66          
  67                  Remarks:
  68                          External buffer required, defined as tmp_buf
  69          */
  70          
  71          int enc_dec_ecb(unsigned char cmd, unsigned char *key, unsigned char *in,  unsigned char inlen, 
  72                                             unsigned char *out, unsigned char *outlen)
  73          {
  74   1              unsigned char ret = 0;
  75   1              unsigned char length = 0;
  76   1              if ((inlen > 248)||(inlen < 1))
  77   1              {
  78   2                      return ERR_INVALID_PARAMETER;
  79   2              } 
  80   1              length = ((inlen+7)>>3)<<3;
  81   1              if (*outlen < length) /* insufficient buffer size */
  82   1              {
  83   2                      return ERR_INVALID_PARAMETER;
  84   2              } 
  85   1              ret = _mem_copy(tmp_buf, in, inlen);
  86   1              if (ret != SES_SUCCESS)
  87   1              {
  88   2                      last_ses_error = ret;
  89   2                      return ERR_SES;
  90   2              }
  91   1              switch(cmd)
  92   1              {
  93   2                      case DES_ENC_ECB:
  94   2                              ret = _des_enc(key, inlen, tmp_buf);                    
  95   2                      break;
  96   2                      case DES_DEC_ECB:
  97   2                              ret = _des_dec(key, inlen, tmp_buf);                                            
  98   2                      break;
  99   2                      case TDES_ENC_ECB:
 100   2                              ret = _tdes_enc(key, inlen, tmp_buf);                   
 101   2                      break;
 102   2                      case TDES_DEC_ECB:
 103   2                              ret = _tdes_dec(key, inlen, tmp_buf);                   
 104   2                      break;          
 105   2                      default:
 106   2                              return ERR_INVALID_PARAMETER;
 107   2              }
 108   1              if (ret != SES_SUCCESS)
 109   1              {
 110   2                      last_ses_error = ret;
 111   2                      return ERR_SES;
 112   2              }
 113   1              ret = _mem_copy(out, tmp_buf, length);
 114   1              if (ret != SES_SUCCESS)
 115   1              {
 116   2                      last_ses_error = ret;
 117   2                      return ERR_SES;
C51 COMPILER V7.10   SAMPLE_26_HW                                                          08/04/2011 10:36:56 PAGE 3   

 118   2              }
 119   1              *outlen = length;
 120   1              return ERR_SUCCESS;
 121   1      }
 122          
 123          /*
 124                  This function do DES/TDES en/decryption in CBC mode .
 125                  
 126                  Parameters:
 127                          cmd[in]: command 
 128                          key[in]: secret key
 129                          iv[in]:  initial vector
 130                          in[in]:  input data
 131                          inlen[in]: input data length
 132                          out[out]: output data
 133                          outlen[in,out]: [in]out buffer size &&[out]output length 
 134                  Return: 
 135                          If the function succeeds, it will return ERR_SUCCESS, otherwise 
 136                          it returns corresponding error code.
 137          
 138                  Remarks:
 139                          External buffer required, defined as tmp_buf
 140          */
 141          int enc_dec_cbc(unsigned char cmd, unsigned char *key, unsigned char *iv, unsigned char *in,  unsigned cha
             -r inlen, 
 142                                            unsigned char *out, unsigned char *outlen)
 143          {
 144   1              unsigned char ret = 0;
 145   1              unsigned char length = 0;
 146   1              unsigned char tmp_iv[8];
 147   1              unsigned char inputBlock[8];
 148   1              unsigned int i = 0;
 149   1              unsigned int j = 0;
 150   1      
 151   1              length = ((inlen+7)>>3)<<3;
 152   1              if (*outlen < length) /* insufficient buffer size */
 153   1              {
 154   2                      return ERR_INVALID_PARAMETER;
 155   2              } 
 156   1              ret = _mem_copy(tmp_buf, in, inlen);
 157   1              if (ret != SES_SUCCESS)
 158   1              {
 159   2                      last_ses_error = ret;
 160   2                      return ERR_SES;
 161   2              }
 162   1              ret = _mem_copy(tmp_iv, iv, sizeof(tmp_iv));
 163   1              if (ret != SES_SUCCESS)
 164   1              {
 165   2                      last_ses_error = ret;
 166   2                      return ERR_SES;
 167   2              }
 168   1              
 169   1              if (inlen % 8)
 170   1              {
 171   2                      //tmp_buf[inlen] = 0x80;
 172   2                      tmp_buf[inlen] = 0x00;
 173   2                      if (inlen % 8 > 1)
 174   2                      {
 175   3                              ret = _mem_set((tmp_buf + inlen + 1), 0x00, inlen%8-1);
 176   3                              if (ret != SES_SUCCESS)
 177   3                              {
 178   4                                      last_ses_error = ret;
C51 COMPILER V7.10   SAMPLE_26_HW                                                          08/04/2011 10:36:56 PAGE 4   

 179   4                                      return ERR_SES;
 180   4                              }
 181   3                      }
 182   2              }
 183   1              for (i = 0; i < length/8; i++) 
 184   1              {
 185   2                  /* Chain if encrypting.
 186   2                   */
 187   2                  if (cmd == DES_ENC_CBC || cmd == TDES_ENC_CBC)
 188   2                      {
 189   3                              for (j = 0; j < 8; j++)
 190   3                              {
 191   4                                      tmp_buf[i*8+j] ^= tmp_iv[j]; 
 192   4                              }
 193   3                              if (cmd == DES_ENC_CBC)
 194   3                              {
 195   4                                      ret = _des_enc(key, 8, &tmp_buf[i*8]);
 196   4                              }
 197   3                              else
 198   3                              {
 199   4                                      ret = _tdes_enc(key, 8, &tmp_buf[i*8]);
 200   4                              }
 201   3                              ret = _mem_copy(tmp_iv, &tmp_buf[i*8], 8);
 202   3              
 203   3                      }
 204   2                      else
 205   2                      {
 206   3                              ret = _mem_copy(inputBlock, &tmp_buf[i*8], 8);
 207   3                              if (cmd == DES_DEC_CBC)
 208   3                              {
 209   4                                      ret = _des_dec(key, 8, &tmp_buf[i*8]);
 210   4                              }
 211   3                              else
 212   3                              {
 213   4                                      ret = _tdes_dec(key, 8, &tmp_buf[i*8]);
 214   4                              }
 215   3                              for (j = 0; j < 8; j++)
 216   3                              {
 217   4                                      tmp_buf[i*8+j] ^= tmp_iv[j]; 
 218   4                              }
 219   3                              ret = _mem_copy(tmp_iv, inputBlock, 8);
 220   3                      }
 221   2              
 222   2              }  
 223   1      
 224   1              if (ret != SES_SUCCESS)
 225   1              {
 226   2                      last_ses_error = ret;
 227   2                      return ERR_SES;
 228   2              }
 229   1              ret = _mem_copy(out, tmp_buf, length);
 230   1              if (ret != SES_SUCCESS)
 231   1              {
 232   2                      last_ses_error = ret;
 233   2                      return ERR_SES;
 234   2              }
 235   1              /* Zeroize sensitive information.
 236   1              */
 237   1              ret = _mem_set (tmp_buf, 0, sizeof (tmp_buf));
 238   1              if (ret != SES_SUCCESS)
 239   1              {
 240   2                      last_ses_error = ret;
C51 COMPILER V7.10   SAMPLE_26_HW                                                          08/04/2011 10:36:56 PAGE 5   

 241   2                      return ERR_SES;
 242   2              }
 243   1      
 244   1              *outlen = length;
 245   1              return ERR_SUCCESS;
 246   1      }
 247          
 248          void main()
 249          {
 250   1              int ret = 0;
 251   1              unsigned char length = 0;
 252   1              // use "idata" to avoid key stored in "share memory" being revealed by other EXF
 253   1              unsigned char idata key[16] = {0x06,0x09,0x0A,0x03,0x09,0x05,0x0F,0x04,0x02,0x02,0x01,0x07,0x06,0x01,0x02
             -,0x07};
 254   1              DATA_BLOCK *dblk = NULL;
 255   1              switch(input->tag)
 256   1              {
 257   2                      case DES_ENC_ECB:
 258   2                      case DES_DEC_ECB:
 259   2                      case TDES_ENC_ECB:
 260   2                      case TDES_DEC_ECB:
 261   2                              length = sizeof(tmp_buf);
 262   2                              ret = enc_dec_ecb(input->tag, key, input->buff, input->len, &output->buff, &length);
 263   2                      break;
 264   2                      case DES_ENC_CBC:
 265   2                      case DES_DEC_CBC:
 266   2                      case TDES_ENC_CBC:
 267   2                      case TDES_DEC_CBC:
 268   2                              dblk = (DATA_BLOCK *)input->buff;
 269   2                              length = sizeof(tmp_buf);                       
 270   2                              ret = enc_dec_cbc(input->tag, key, dblk->iv, dblk->buff, dblk->len, &output->buff, &length);
 271   2                      break;
 272   2                      default:
 273   2                              error_exit(ERR_INVALID_PARAMETER, NULL, 0);
 274   2              }
 275   1              if (ret != ERR_SUCCESS)
 276   1              {
 277   2                      if (ret == ERR_SES)
 278   2                      {
 279   3                              error_exit(ret , &last_ses_error, 1);
 280   3                      }
 281   2                      else
 282   2                      {
 283   3                              error_exit(ret, NULL, 0);
 284   3                      }
 285   2              }
 286   1              output->tag = ERR_SUCCESS;
 287   1              output->len = length;
 288   1              _set_response(IO_PACKAGE_HEADER_SIZE+output->len, (unsigned char *)output);
 289   1              _exit();  
 290   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1977    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =    505      66
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----      16
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V7.10   SAMPLE_26_HW                                                          08/04/2011 10:36:56 PAGE 6   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
